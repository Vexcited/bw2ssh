use clap::Parser;
use serde::Deserialize;
use sha2::{Digest, Sha256};
use std::fs;
use std::path::PathBuf;
use std::process::Command;

#[derive(Parser, Debug)]
#[command(name = "bw2ssh")]
#[command(about = "Build .ssh/config from Bitwarden", long_about = None)]
struct Args {
    /// Bitwarden session token.
    #[arg(short, long)]
    token: String,
}

#[derive(Debug, Deserialize)]
struct BitwardenItem {
    name: String,
    #[serde(rename = "sshKey")]
    ssh_key: Option<BitwardenSshKey>,
    fields: Option<Vec<BitwardenField>>,
}

#[derive(Debug, Deserialize)]
struct BitwardenSshKey {
    #[serde(rename = "publicKey")]
    public_key: String,
}

#[derive(Debug, Deserialize)]
struct BitwardenField {
    name: String,
    value: String,
}

struct Entry {
    name: String,
    hosts: Vec<String>,
    hostname: Option<String>,
    user: Option<String>,
    public_key: String,
    key_path: String,
}

const TAB: &str = "  ";

/// Retrieve the SSH directory depending on the OS.
fn get_ssh_dir() -> PathBuf {
    let home = std::env::var("HOME")
        .or_else(|_| std::env::var("USERPROFILE"))
        .expect("could not determine home directory");

    PathBuf::from(home).join(".ssh")
}

fn delete_previous_configs() {
    let ssh_dir = get_ssh_dir();

    // delete previous configuration ~/.ssh/config
    let config_path = ssh_dir.join("config");
    if config_path.exists() {
        fs::remove_file(&config_path).ok();
    }

    // delete previously imported public keys
    if let Ok(entries) = fs::read_dir(&ssh_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if let Some(filename) = path.file_name().and_then(|s| s.to_str())
                && filename.starts_with("bw_")
                && path.extension().and_then(|s| s.to_str()) == Some("pub")
            {
                fs::remove_file(&path).ok();
            }
        }
    }
}

fn get_bitwarden_items(token: &str) -> Result<Vec<BitwardenItem>, Box<dyn std::error::Error>> {
    let bw_command = if cfg!(windows) { "bw.cmd" } else { "bw" };

    let output = Command::new(bw_command)
        .arg("list")
        .arg("items")
        .arg("--session")
        .arg(token)
        .output()?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("bw error: {}", stderr).into());
    }

    let stdout = String::from_utf8(output.stdout)?;
    let items: Vec<BitwardenItem> = serde_json::from_str(&stdout)?;

    Ok(items)
}

fn extract_custom_field(fields: &Option<Vec<BitwardenField>>, name: &str) -> Option<String> {
    fields
        .as_ref()?
        .iter()
        .find(|f| f.name.eq_ignore_ascii_case(name))
        .map(|f| f.value.clone())
}

fn parse_entries(items: Vec<BitwardenItem>) -> Vec<Entry> {
    items
        .into_iter()
        .filter_map(|item| {
            let ssh_key = item.ssh_key.as_ref()?;

            let hosts_str = extract_custom_field(&item.fields, "HOSTS")?;
            let hosts: Vec<String> = hosts_str
                .split(',')
                .map(|h| h.trim().to_string())
                .filter(|h| !h.is_empty())
                .collect();

            if hosts.is_empty() {
                return None;
            }

            // optional fields.
            let hostname = extract_custom_field(&item.fields, "HOSTNAME");
            let user = extract_custom_field(&item.fields, "USER");

            // generate filename based public key hash.
            let hash = format!("{:x}", Sha256::digest(ssh_key.public_key.as_bytes()));
            let key_path = format!("bw_{}.pub", &hash[..16]);

            Some(Entry {
                name: item.name,
                hosts,
                hostname,
                user,
                public_key: ssh_key.public_key.clone(),
                key_path,
            })
        })
        .collect()
}

fn generate_ssh_config(configs: &[Entry]) -> String {
    let entries: Vec<String> = configs
        .iter()
        .map(|config| {
            let mut lines = vec![
                format!("# {}", config.name),
                format!("Host {}", config.hosts.join(" ")),
            ];

            if let Some(hostname) = &config.hostname {
                lines.push(format!("{TAB}HostName {}", hostname));
            }

            if let Some(user) = &config.user {
                lines.push(format!("{TAB}User {}", user));
            }

            lines.push(format!("{TAB}IdentitiesOnly yes"));
            lines.push(format!("{TAB}IdentityFile ~/.ssh/{}", config.key_path));

            lines.join("\n")
        })
        .collect();

    let header = "# THIS FILE HAS BEEN GENERATED BY bw2ssh.\n# DO NOT EDIT IT!";
    format!("{header}\n\n{}", entries.join("\n\n"))
}

fn main() {
    let args = Args::parse();

    println!("fetching keys...");
    let items = match get_bitwarden_items(&args.token) {
        Ok(items) => items,
        Err(e) => {
            eprintln!("error: {}", e);
            std::process::exit(1);
        }
    };

    let entries = parse_entries(items);

    if entries.is_empty() {
        eprintln!("no keys found");
        std::process::exit(1);
    }

    println!("found {} key(s)", entries.len());
    delete_previous_configs();

    let ssh_dir = get_ssh_dir();

    // make sure the directory exists.
    fs::create_dir_all(&ssh_dir).expect("failed to create .ssh directory");

    // write public keys.
    for config in &entries {
        let key_path = ssh_dir.join(&config.key_path);
        fs::write(&key_path, &config.public_key)
            .unwrap_or_else(|_| panic!("failed to write {}", config.key_path));
    }

    // generate and write config.
    let config_content = generate_ssh_config(&entries);
    let config_path = ssh_dir.join("config");
    fs::write(&config_path, &config_content).expect("failed to write config");

    println!("wrote {} for the following keys:", config_path.display());
    for config in &entries {
        println!("{TAB}- {}", config.name);
    }
}
